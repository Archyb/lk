/**
 * virtual-core
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('./_virtual/_rollupPluginBabelHelpers.js');
var utils = require('./utils.js');

//

//

var defaultKeyExtractor = function defaultKeyExtractor(index) {
  return index;
};
var defaultRangeExtractor = function defaultRangeExtractor(range) {
  var start = Math.max(range.startIndex - range.overscan, 0);
  var end = Math.min(range.endIndex + range.overscan, range.count - 1);
  var arr = [];
  for (var _i = start; _i <= end; _i++) {
    arr.push(_i);
  }
  return arr;
};
var memoRectCallback = function memoRectCallback(instance, cb) {
  var prev = {
    height: -1,
    width: -1
  };
  return function (rect) {
    if (instance.options.horizontal ? rect.width !== prev.width : rect.height !== prev.height) {
      cb(rect);
    }
    prev = rect;
  };
};
var observeElementRect = function observeElementRect(instance, cb) {
  var observer = new ResizeObserver(function (entries) {
    var _entries$, _entries$2;
    cb({
      width: (_entries$ = entries[0]) == null ? void 0 : _entries$.contentRect.width,
      height: (_entries$2 = entries[0]) == null ? void 0 : _entries$2.contentRect.height
    });
  });
  if (!instance.scrollElement) {
    return;
  }
  cb(instance.scrollElement.getBoundingClientRect());
  observer.observe(instance.scrollElement);
  return function () {
    observer.unobserve(instance.scrollElement);
  };
};
var observeWindowRect = function observeWindowRect(instance, cb) {
  var memoizedCallback = memoRectCallback(instance, cb);
  var onResize = function onResize() {
    return memoizedCallback({
      width: instance.scrollElement.innerWidth,
      height: instance.scrollElement.innerHeight
    });
  };
  if (!instance.scrollElement) {
    return;
  }
  onResize();
  instance.scrollElement.addEventListener('resize', onResize, {
    capture: false,
    passive: true
  });
  return function () {
    instance.scrollElement.removeEventListener('resize', onResize);
  };
};
var scrollProps = {
  element: ['scrollLeft', 'scrollTop'],
  window: ['scrollX', 'scrollY']
};
var createOffsetObserver = function createOffsetObserver(mode) {
  return function (instance, cb) {
    if (!instance.scrollElement) {
      return;
    }
    var propX = scrollProps[mode][0];
    var propY = scrollProps[mode][1];
    var prevX = instance.scrollElement[propX];
    var prevY = instance.scrollElement[propY];
    var scroll = function scroll() {
      var offset = instance.scrollElement[instance.options.horizontal ? propX : propY];
      cb(Math.max(0, offset - instance.options.scrollMargin));
    };
    scroll();
    var onScroll = function onScroll(e) {
      var target = e.currentTarget;
      var scrollX = target[propX];
      var scrollY = target[propY];
      if (instance.options.horizontal ? prevX - scrollX : prevY - scrollY) {
        scroll();
      }
      prevX = scrollX;
      prevY = scrollY;
    };
    instance.scrollElement.addEventListener('scroll', onScroll, {
      capture: false,
      passive: true
    });
    return function () {
      instance.scrollElement.removeEventListener('scroll', onScroll);
    };
  };
};
var observeElementOffset = createOffsetObserver('element');
var observeWindowOffset = createOffsetObserver('window');
var measureElement = function measureElement(element, instance) {
  return Math.round(element.getBoundingClientRect()[instance.options.horizontal ? 'width' : 'height']);
};
var windowScroll = function windowScroll(offset, _ref, instance) {
  var _instance$scrollEleme, _instance$scrollEleme2;
  var adjustments = _ref.adjustments,
    behavior = _ref.behavior,
    sync = _ref.sync;
  var toOffset = (sync ? offset : offset + instance.options.scrollMargin) + (adjustments != null ? adjustments : 0);
  (_instance$scrollEleme = instance.scrollElement) == null ? void 0 : _instance$scrollEleme.scrollTo == null ? void 0 : _instance$scrollEleme.scrollTo((_instance$scrollEleme2 = {}, _instance$scrollEleme2[instance.options.horizontal ? 'left' : 'top'] = toOffset, _instance$scrollEleme2.behavior = behavior, _instance$scrollEleme2));
};
var elementScroll = function elementScroll(offset, _ref2, instance) {
  var _instance$scrollEleme3, _instance$scrollEleme4;
  var adjustments = _ref2.adjustments,
    behavior = _ref2.behavior,
    sync = _ref2.sync;
  var toOffset = (sync ? offset : offset + instance.options.scrollMargin) + (adjustments != null ? adjustments : 0);
  (_instance$scrollEleme3 = instance.scrollElement) == null ? void 0 : _instance$scrollEleme3.scrollTo == null ? void 0 : _instance$scrollEleme3.scrollTo((_instance$scrollEleme4 = {}, _instance$scrollEleme4[instance.options.horizontal ? 'left' : 'top'] = toOffset, _instance$scrollEleme4.behavior = behavior, _instance$scrollEleme4));
};
var Virtualizer = function Virtualizer(_opts) {
  var _this = this;
  this.unsubs = [];
  this.scrollElement = null;
  this.isScrolling = false;
  this.isScrollingTimeoutId = null;
  this.measurementsCache = [];
  this.itemMeasurementsCache = {};
  this.pendingMeasuredCacheIndexes = [];
  this.scrollAdjustments = 0;
  this.measureElementCache = {};
  this.pendingScrollToIndexCallback = null;
  this.getResizeObserver = function () {
    var _ro = null;
    return function () {
      if (_ro) {
        return _ro;
      } else if (typeof ResizeObserver !== 'undefined') {
        return _ro = new ResizeObserver(function (entries) {
          entries.forEach(function (entry) {
            _this._measureElement(entry.target, false);
          });
        });
      } else {
        return null;
      }
    };
  }();
  this.range = {
    startIndex: 0,
    endIndex: 0
  };
  this.setOptions = function (opts) {
    Object.entries(opts).forEach(function (_ref3) {
      var key = _ref3[0],
        value = _ref3[1];
      if (typeof value === 'undefined') delete opts[key];
    });
    _this.options = _rollupPluginBabelHelpers["extends"]({
      debug: false,
      initialOffset: 0,
      overscan: 1,
      paddingStart: 0,
      paddingEnd: 0,
      scrollPaddingStart: 0,
      scrollPaddingEnd: 0,
      horizontal: false,
      getItemKey: defaultKeyExtractor,
      rangeExtractor: defaultRangeExtractor,
      onChange: function onChange() {},
      measureElement: measureElement,
      initialRect: {
        width: 0,
        height: 0
      },
      scrollMargin: 0,
      scrollingDelay: 150,
      indexAttribute: 'data-index'
    }, opts);
  };
  this.notify = function () {
    _this.options.onChange == null ? void 0 : _this.options.onChange(_this);
  };
  this.cleanup = function () {
    _this.unsubs.filter(Boolean).forEach(function (d) {
      return d();
    });
    _this.unsubs = [];
    _this.scrollElement = null;
  };
  this._didMount = function () {
    var ro = _this.getResizeObserver();
    Object.values(_this.measureElementCache).forEach(function (node) {
      return ro == null ? void 0 : ro.observe(node);
    });
    return function () {
      ro == null ? void 0 : ro.disconnect();
      _this.cleanup();
    };
  };
  this._willUpdate = function () {
    _this.pendingScrollToIndexCallback == null ? void 0 : _this.pendingScrollToIndexCallback();
    var scrollElement = _this.options.getScrollElement();
    if (_this.scrollElement !== scrollElement) {
      _this.cleanup();
      _this.scrollElement = scrollElement;
      _this._scrollToOffset(_this.scrollOffset, {
        adjustments: undefined,
        behavior: undefined,
        sync: true
      });
      _this.unsubs.push(_this.options.observeElementRect(_this, function (rect) {
        _this.scrollRect = rect;
        _this.calculateRange();
      }));
      _this.unsubs.push(_this.options.observeElementOffset(_this, function (offset) {
        if (_this.isScrollingTimeoutId !== null) {
          clearTimeout(_this.isScrollingTimeoutId);
          _this.isScrollingTimeoutId = null;
        }
        var onIsScrollingChange = function onIsScrollingChange(isScrolling) {
          if (_this.isScrolling !== isScrolling) {
            _this.isScrolling = isScrolling;
            _this.notify();
          }
        };
        _this.scrollAdjustments = 0;
        if (_this.scrollOffset !== offset) {
          _this.scrollOffset = offset;
          onIsScrollingChange(true);
        }
        _this.calculateRange();
        _this.isScrollingTimeoutId = setTimeout(function () {
          _this.isScrollingTimeoutId = null;
          onIsScrollingChange(false);
        }, _this.options.scrollingDelay);
      }));
    } else if (!_this.isScrolling) {
      _this.calculateRange();
    }
  };
  this.getSize = function () {
    return _this.scrollRect[_this.options.horizontal ? 'width' : 'height'];
  };
  this.getMeasurements = utils.memo(function () {
    return [_this.options.count, _this.options.paddingStart, _this.options.getItemKey, _this.itemMeasurementsCache];
  }, function (count, paddingStart, getItemKey, measurementsCache) {
    var min = _this.pendingMeasuredCacheIndexes.length > 0 ? Math.min.apply(Math, _this.pendingMeasuredCacheIndexes) : 0;
    _this.pendingMeasuredCacheIndexes = [];
    var measurements = _this.measurementsCache.slice(0, min);
    for (var _i2 = min; _i2 < count; _i2++) {
      var key = getItemKey(_i2);
      var measuredSize = measurementsCache[key];
      var start = measurements[_i2 - 1] ? measurements[_i2 - 1].end : paddingStart;
      var size = typeof measuredSize === 'number' ? measuredSize : _this.options.estimateSize(_i2);
      var end = start + size;
      measurements[_i2] = {
        index: _i2,
        start: start,
        size: size,
        end: end,
        key: key
      };
    }
    _this.measurementsCache = measurements;
    return measurements;
  }, {
    key: process.env.NODE_ENV !== 'production' && 'getMeasurements',
    debug: function debug() {
      return _this.options.debug;
    }
  });
  this.calculateRange = utils.memo(function () {
    return [_this.getMeasurements(), _this.getSize(), _this.scrollOffset];
  }, function (measurements, outerSize, scrollOffset) {
    var range = calculateRange({
      measurements: measurements,
      outerSize: outerSize,
      scrollOffset: scrollOffset
    });
    if (range.startIndex !== _this.range.startIndex || range.endIndex !== _this.range.endIndex) {
      _this.range = range;
      _this.notify();
    }
    return _this.range;
  }, {
    key: process.env.NODE_ENV !== 'production' && 'calculateRange',
    debug: function debug() {
      return _this.options.debug;
    }
  });
  this.getIndexes = utils.memo(function () {
    return [_this.options.rangeExtractor, _this.range, _this.options.overscan, _this.options.count];
  }, function (rangeExtractor, range, overscan, count) {
    return rangeExtractor(_rollupPluginBabelHelpers["extends"]({}, range, {
      overscan: overscan,
      count: count
    }));
  }, {
    key: process.env.NODE_ENV !== 'production' && 'getIndexes',
    debug: function debug() {
      return _this.options.debug;
    }
  });
  this.indexFromElement = function (node) {
    var attributeName = _this.options.indexAttribute;
    var indexStr = node.getAttribute(attributeName);
    if (!indexStr) {
      console.warn("Missing attribute name '" + attributeName + "={index}' on measured element.");
      return -1;
    }
    return parseInt(indexStr, 10);
  };
  this._measureElement = function (node, _sync) {
    var _this$itemMeasurement;
    var index = _this.indexFromElement(node);
    var item = _this.measurementsCache[index];
    if (!item) {
      return;
    }
    var prevNode = _this.measureElementCache[item.key];
    var ro = _this.getResizeObserver();
    if (!node.isConnected) {
      if (prevNode) {
        ro == null ? void 0 : ro.unobserve(prevNode);
        delete _this.measureElementCache[item.key];
      }
      return;
    }
    if (!prevNode || prevNode !== node) {
      if (prevNode) {
        ro == null ? void 0 : ro.unobserve(prevNode);
      }
      _this.measureElementCache[item.key] = node;
      ro == null ? void 0 : ro.observe(node);
    }
    var measuredItemSize = _this.options.measureElement(node, _this);
    var itemSize = (_this$itemMeasurement = _this.itemMeasurementsCache[item.key]) != null ? _this$itemMeasurement : item.size;
    var delta = measuredItemSize - itemSize;
    if (delta !== 0) {
      var _extends2;
      if (item.start < _this.scrollOffset && _this.isScrolling) {
        if (process.env.NODE_ENV !== 'production' && _this.options.debug) {
          console.info('correction', delta);
        }
        _this._scrollToOffset(_this.scrollOffset, {
          adjustments: _this.scrollAdjustments += delta,
          behavior: undefined,
          sync: false
        });
      }
      _this.pendingMeasuredCacheIndexes.push(index);
      _this.itemMeasurementsCache = _rollupPluginBabelHelpers["extends"]({}, _this.itemMeasurementsCache, (_extends2 = {}, _extends2[item.key] = measuredItemSize, _extends2));
      _this.notify();
    }
  };
  this.measureElement = function (node) {
    if (!node) {
      return;
    }
    _this._measureElement(node, true);
  };
  this.getVirtualItems = utils.memo(function () {
    return [_this.getIndexes(), _this.getMeasurements()];
  }, function (indexes, measurements) {
    var virtualItems = [];
    for (var k = 0, len = indexes.length; k < len; k++) {
      var _i3 = indexes[k];
      var measurement = measurements[_i3];
      virtualItems.push(measurement);
    }
    return virtualItems;
  }, {
    key: process.env.NODE_ENV !== 'production' && 'getIndexes',
    debug: function debug() {
      return _this.options.debug;
    }
  });
  this.getOffsetForAlignment = function (toOffset, align) {
    var offset = _this.scrollOffset;
    var size = _this.getSize();
    if (align === 'auto') {
      if (toOffset <= offset) {
        align = 'start';
      } else if (toOffset >= offset + size) {
        align = 'end';
      } else {
        align = 'start';
      }
    }
    if (align === 'start') {
      return toOffset;
    } else if (align === 'end') {
      return toOffset - size;
    } else if (align === 'center') {
      return toOffset - size / 2;
    }
    return toOffset;
  };
  this.scrollToOffset = function (toOffset, _temp) {
    var _ref4 = _temp === void 0 ? {} : _temp,
      _ref4$align = _ref4.align,
      align = _ref4$align === void 0 ? 'start' : _ref4$align,
      behavior = _ref4.behavior;
    var options = {
      adjustments: undefined,
      behavior: behavior,
      sync: false
    };
    _this._scrollToOffset(_this.getOffsetForAlignment(toOffset, align), options);
  };
  this.scrollToIndex = function (index, _temp2) {
    var _ref5 = _temp2 === void 0 ? {} : _temp2,
      _ref5$align = _ref5.align,
      align = _ref5$align === void 0 ? 'auto' : _ref5$align,
      behavior = _ref5.behavior;
    _this.pendingScrollToIndexCallback = null;
    var offset = _this.scrollOffset;
    var size = _this.getSize();
    var count = _this.options.count;
    var measurements = _this.getMeasurements();
    var measurement = measurements[Math.max(0, Math.min(index, count - 1))];
    if (!measurement) {
      throw new Error("VirtualItem not found for index = " + index);
    }
    if (align === 'auto') {
      if (measurement.end >= offset + size - _this.options.scrollPaddingEnd) {
        align = 'end';
      } else if (measurement.start <= offset + _this.options.scrollPaddingStart) {
        align = 'start';
      } else {
        return;
      }
    }
    var getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(measurement) {
      var toOffset = align === 'end' ? measurement.end + _this.options.scrollPaddingEnd : measurement.start - _this.options.scrollPaddingStart;
      return _this.getOffsetForAlignment(toOffset, align);
    };
    var toOffset = getOffsetForIndexAndAlignment(measurement);
    if (toOffset === offset) {
      return;
    }
    var options = {
      adjustments: undefined,
      behavior: behavior,
      sync: false
    };
    _this._scrollToOffset(toOffset, options);
    var isDynamic = Object.keys(_this.measureElementCache).length > 0;
    if (isDynamic) {
      _this.pendingScrollToIndexCallback = function () {
        _this.scrollToIndex(index, {
          align: align,
          behavior: behavior
        });
      };
    }
  };
  this.scrollBy = function (adjustments, options) {
    _this._scrollToOffset(_this.scrollOffset, {
      adjustments: adjustments,
      behavior: options == null ? void 0 : options.behavior,
      sync: false
    });
  };
  this.getTotalSize = function () {
    var _this$getMeasurements;
    return (((_this$getMeasurements = _this.getMeasurements()[_this.options.count - 1]) == null ? void 0 : _this$getMeasurements.end) || _this.options.paddingStart) + _this.options.paddingEnd;
  };
  this._scrollToOffset = function (offset, _ref6) {
    var adjustments = _ref6.adjustments,
      behavior = _ref6.behavior,
      sync = _ref6.sync;
    _this.options.scrollToFn(offset, {
      behavior: behavior,
      sync: sync,
      adjustments: adjustments
    }, _this);
  };
  this.measure = function () {
    _this.itemMeasurementsCache = {};
    _this.notify();
  };
  this.setOptions(_opts);
  this.scrollRect = this.options.initialRect;
  this.scrollOffset = this.options.initialOffset;
  this.calculateRange();
};
var findNearestBinarySearch = function findNearestBinarySearch(low, high, getCurrentValue, value) {
  while (low <= high) {
    var middle = (low + high) / 2 | 0;
    var currentValue = getCurrentValue(middle);
    if (currentValue < value) {
      low = middle + 1;
    } else if (currentValue > value) {
      high = middle - 1;
    } else {
      return middle;
    }
  }
  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};
function calculateRange(_ref7) {
  var measurements = _ref7.measurements,
    outerSize = _ref7.outerSize,
    scrollOffset = _ref7.scrollOffset;
  var count = measurements.length - 1;
  var getOffset = function getOffset(index) {
    return measurements[index].start;
  };
  var startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset);
  var endIndex = startIndex;
  while (endIndex < count && measurements[endIndex].end < scrollOffset + outerSize) {
    endIndex++;
  }
  return {
    startIndex: startIndex,
    endIndex: endIndex
  };
}

exports.memo = utils.memo;
exports.Virtualizer = Virtualizer;
exports.defaultKeyExtractor = defaultKeyExtractor;
exports.defaultRangeExtractor = defaultRangeExtractor;
exports.elementScroll = elementScroll;
exports.measureElement = measureElement;
exports.observeElementOffset = observeElementOffset;
exports.observeElementRect = observeElementRect;
exports.observeWindowOffset = observeWindowOffset;
exports.observeWindowRect = observeWindowRect;
exports.windowScroll = windowScroll;
//# sourceMappingURL=index.js.map
