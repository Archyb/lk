{"ast":null,"code":"/**\n * virtual-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { extends as _extends } from './_virtual/_rollupPluginBabelHelpers.mjs';\nimport { memo } from './utils.mjs';\nexport { memo } from './utils.mjs';\n\n//\n\n//\n\nvar defaultKeyExtractor = function defaultKeyExtractor(index) {\n  return index;\n};\nvar defaultRangeExtractor = function defaultRangeExtractor(range) {\n  var start = Math.max(range.startIndex - range.overscan, 0);\n  var end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  var arr = [];\n  for (var _i = start; _i <= end; _i++) {\n    arr.push(_i);\n  }\n  return arr;\n};\nvar memoRectCallback = function memoRectCallback(instance, cb) {\n  var prev = {\n    height: -1,\n    width: -1\n  };\n  return function (rect) {\n    if (instance.options.horizontal ? rect.width !== prev.width : rect.height !== prev.height) {\n      cb(rect);\n    }\n    prev = rect;\n  };\n};\nvar observeElementRect = function observeElementRect(instance, cb) {\n  var observer = new ResizeObserver(function (entries) {\n    var _entries$, _entries$2;\n    cb({\n      width: (_entries$ = entries[0]) == null ? void 0 : _entries$.contentRect.width,\n      height: (_entries$2 = entries[0]) == null ? void 0 : _entries$2.contentRect.height\n    });\n  });\n  if (!instance.scrollElement) {\n    return;\n  }\n  cb(instance.scrollElement.getBoundingClientRect());\n  observer.observe(instance.scrollElement);\n  return function () {\n    observer.unobserve(instance.scrollElement);\n  };\n};\nvar observeWindowRect = function observeWindowRect(instance, cb) {\n  var memoizedCallback = memoRectCallback(instance, cb);\n  var onResize = function onResize() {\n    return memoizedCallback({\n      width: instance.scrollElement.innerWidth,\n      height: instance.scrollElement.innerHeight\n    });\n  };\n  if (!instance.scrollElement) {\n    return;\n  }\n  onResize();\n  instance.scrollElement.addEventListener('resize', onResize, {\n    capture: false,\n    passive: true\n  });\n  return function () {\n    instance.scrollElement.removeEventListener('resize', onResize);\n  };\n};\nvar scrollProps = {\n  element: ['scrollLeft', 'scrollTop'],\n  window: ['scrollX', 'scrollY']\n};\nvar createOffsetObserver = function createOffsetObserver(mode) {\n  return function (instance, cb) {\n    if (!instance.scrollElement) {\n      return;\n    }\n    var propX = scrollProps[mode][0];\n    var propY = scrollProps[mode][1];\n    var prevX = instance.scrollElement[propX];\n    var prevY = instance.scrollElement[propY];\n    var scroll = function scroll() {\n      var offset = instance.scrollElement[instance.options.horizontal ? propX : propY];\n      cb(Math.max(0, offset - instance.options.scrollMargin));\n    };\n    scroll();\n    var onScroll = function onScroll(e) {\n      var target = e.currentTarget;\n      var scrollX = target[propX];\n      var scrollY = target[propY];\n      if (instance.options.horizontal ? prevX - scrollX : prevY - scrollY) {\n        scroll();\n      }\n      prevX = scrollX;\n      prevY = scrollY;\n    };\n    instance.scrollElement.addEventListener('scroll', onScroll, {\n      capture: false,\n      passive: true\n    });\n    return function () {\n      instance.scrollElement.removeEventListener('scroll', onScroll);\n    };\n  };\n};\nvar observeElementOffset = createOffsetObserver('element');\nvar observeWindowOffset = createOffsetObserver('window');\nvar measureElement = function measureElement(element, instance) {\n  return Math.round(element.getBoundingClientRect()[instance.options.horizontal ? 'width' : 'height']);\n};\nvar windowScroll = function windowScroll(offset, _ref, instance) {\n  var _instance$scrollEleme, _instance$scrollEleme2;\n  var adjustments = _ref.adjustments,\n    behavior = _ref.behavior,\n    sync = _ref.sync;\n  var toOffset = (sync ? offset : offset + instance.options.scrollMargin) + (adjustments != null ? adjustments : 0);\n  (_instance$scrollEleme = instance.scrollElement) == null ? void 0 : _instance$scrollEleme.scrollTo == null ? void 0 : _instance$scrollEleme.scrollTo((_instance$scrollEleme2 = {}, _instance$scrollEleme2[instance.options.horizontal ? 'left' : 'top'] = toOffset, _instance$scrollEleme2.behavior = behavior, _instance$scrollEleme2));\n};\nvar elementScroll = function elementScroll(offset, _ref2, instance) {\n  var _instance$scrollEleme3, _instance$scrollEleme4;\n  var adjustments = _ref2.adjustments,\n    behavior = _ref2.behavior,\n    sync = _ref2.sync;\n  var toOffset = (sync ? offset : offset + instance.options.scrollMargin) + (adjustments != null ? adjustments : 0);\n  (_instance$scrollEleme3 = instance.scrollElement) == null ? void 0 : _instance$scrollEleme3.scrollTo == null ? void 0 : _instance$scrollEleme3.scrollTo((_instance$scrollEleme4 = {}, _instance$scrollEleme4[instance.options.horizontal ? 'left' : 'top'] = toOffset, _instance$scrollEleme4.behavior = behavior, _instance$scrollEleme4));\n};\nvar Virtualizer = function Virtualizer(_opts) {\n  var _this = this;\n  this.unsubs = [];\n  this.scrollElement = null;\n  this.isScrolling = false;\n  this.isScrollingTimeoutId = null;\n  this.measurementsCache = [];\n  this.itemMeasurementsCache = {};\n  this.pendingMeasuredCacheIndexes = [];\n  this.scrollAdjustments = 0;\n  this.measureElementCache = {};\n  this.pendingScrollToIndexCallback = null;\n  this.getResizeObserver = function () {\n    var _ro = null;\n    return function () {\n      if (_ro) {\n        return _ro;\n      } else if (typeof ResizeObserver !== 'undefined') {\n        return _ro = new ResizeObserver(function (entries) {\n          entries.forEach(function (entry) {\n            _this._measureElement(entry.target, false);\n          });\n        });\n      } else {\n        return null;\n      }\n    };\n  }();\n  this.range = {\n    startIndex: 0,\n    endIndex: 0\n  };\n  this.setOptions = function (opts) {\n    Object.entries(opts).forEach(function (_ref3) {\n      var key = _ref3[0],\n        value = _ref3[1];\n      if (typeof value === 'undefined') delete opts[key];\n    });\n    _this.options = _extends({\n      debug: false,\n      initialOffset: 0,\n      overscan: 1,\n      paddingStart: 0,\n      paddingEnd: 0,\n      scrollPaddingStart: 0,\n      scrollPaddingEnd: 0,\n      horizontal: false,\n      getItemKey: defaultKeyExtractor,\n      rangeExtractor: defaultRangeExtractor,\n      onChange: function onChange() {},\n      measureElement: measureElement,\n      initialRect: {\n        width: 0,\n        height: 0\n      },\n      scrollMargin: 0,\n      scrollingDelay: 150,\n      indexAttribute: 'data-index'\n    }, opts);\n  };\n  this.notify = function () {\n    _this.options.onChange == null ? void 0 : _this.options.onChange(_this);\n  };\n  this.cleanup = function () {\n    _this.unsubs.filter(Boolean).forEach(function (d) {\n      return d();\n    });\n    _this.unsubs = [];\n    _this.scrollElement = null;\n  };\n  this._didMount = function () {\n    var ro = _this.getResizeObserver();\n    Object.values(_this.measureElementCache).forEach(function (node) {\n      return ro == null ? void 0 : ro.observe(node);\n    });\n    return function () {\n      ro == null ? void 0 : ro.disconnect();\n      _this.cleanup();\n    };\n  };\n  this._willUpdate = function () {\n    _this.pendingScrollToIndexCallback == null ? void 0 : _this.pendingScrollToIndexCallback();\n    var scrollElement = _this.options.getScrollElement();\n    if (_this.scrollElement !== scrollElement) {\n      _this.cleanup();\n      _this.scrollElement = scrollElement;\n      _this._scrollToOffset(_this.scrollOffset, {\n        adjustments: undefined,\n        behavior: undefined,\n        sync: true\n      });\n      _this.unsubs.push(_this.options.observeElementRect(_this, function (rect) {\n        _this.scrollRect = rect;\n        _this.calculateRange();\n      }));\n      _this.unsubs.push(_this.options.observeElementOffset(_this, function (offset) {\n        if (_this.isScrollingTimeoutId !== null) {\n          clearTimeout(_this.isScrollingTimeoutId);\n          _this.isScrollingTimeoutId = null;\n        }\n        var onIsScrollingChange = function onIsScrollingChange(isScrolling) {\n          if (_this.isScrolling !== isScrolling) {\n            _this.isScrolling = isScrolling;\n            _this.notify();\n          }\n        };\n        _this.scrollAdjustments = 0;\n        if (_this.scrollOffset !== offset) {\n          _this.scrollOffset = offset;\n          onIsScrollingChange(true);\n        }\n        _this.calculateRange();\n        _this.isScrollingTimeoutId = setTimeout(function () {\n          _this.isScrollingTimeoutId = null;\n          onIsScrollingChange(false);\n        }, _this.options.scrollingDelay);\n      }));\n    } else if (!_this.isScrolling) {\n      _this.calculateRange();\n    }\n  };\n  this.getSize = function () {\n    return _this.scrollRect[_this.options.horizontal ? 'width' : 'height'];\n  };\n  this.getMeasurements = memo(function () {\n    return [_this.options.count, _this.options.paddingStart, _this.options.getItemKey, _this.itemMeasurementsCache];\n  }, function (count, paddingStart, getItemKey, measurementsCache) {\n    var min = _this.pendingMeasuredCacheIndexes.length > 0 ? Math.min.apply(Math, _this.pendingMeasuredCacheIndexes) : 0;\n    _this.pendingMeasuredCacheIndexes = [];\n    var measurements = _this.measurementsCache.slice(0, min);\n    for (var _i2 = min; _i2 < count; _i2++) {\n      var key = getItemKey(_i2);\n      var measuredSize = measurementsCache[key];\n      var start = measurements[_i2 - 1] ? measurements[_i2 - 1].end : paddingStart;\n      var size = typeof measuredSize === 'number' ? measuredSize : _this.options.estimateSize(_i2);\n      var end = start + size;\n      measurements[_i2] = {\n        index: _i2,\n        start: start,\n        size: size,\n        end: end,\n        key: key\n      };\n    }\n    _this.measurementsCache = measurements;\n    return measurements;\n  }, {\n    key: process.env.NODE_ENV !== 'production' && 'getMeasurements',\n    debug: function debug() {\n      return _this.options.debug;\n    }\n  });\n  this.calculateRange = memo(function () {\n    return [_this.getMeasurements(), _this.getSize(), _this.scrollOffset];\n  }, function (measurements, outerSize, scrollOffset) {\n    var range = calculateRange({\n      measurements: measurements,\n      outerSize: outerSize,\n      scrollOffset: scrollOffset\n    });\n    if (range.startIndex !== _this.range.startIndex || range.endIndex !== _this.range.endIndex) {\n      _this.range = range;\n      _this.notify();\n    }\n    return _this.range;\n  }, {\n    key: process.env.NODE_ENV !== 'production' && 'calculateRange',\n    debug: function debug() {\n      return _this.options.debug;\n    }\n  });\n  this.getIndexes = memo(function () {\n    return [_this.options.rangeExtractor, _this.range, _this.options.overscan, _this.options.count];\n  }, function (rangeExtractor, range, overscan, count) {\n    return rangeExtractor(_extends({}, range, {\n      overscan: overscan,\n      count: count\n    }));\n  }, {\n    key: process.env.NODE_ENV !== 'production' && 'getIndexes',\n    debug: function debug() {\n      return _this.options.debug;\n    }\n  });\n  this.indexFromElement = function (node) {\n    var attributeName = _this.options.indexAttribute;\n    var indexStr = node.getAttribute(attributeName);\n    if (!indexStr) {\n      console.warn(\"Missing attribute name '\" + attributeName + \"={index}' on measured element.\");\n      return -1;\n    }\n    return parseInt(indexStr, 10);\n  };\n  this._measureElement = function (node, _sync) {\n    var _this$itemMeasurement;\n    var index = _this.indexFromElement(node);\n    var item = _this.measurementsCache[index];\n    if (!item) {\n      return;\n    }\n    var prevNode = _this.measureElementCache[item.key];\n    var ro = _this.getResizeObserver();\n    if (!node.isConnected) {\n      if (prevNode) {\n        ro == null ? void 0 : ro.unobserve(prevNode);\n        delete _this.measureElementCache[item.key];\n      }\n      return;\n    }\n    if (!prevNode || prevNode !== node) {\n      if (prevNode) {\n        ro == null ? void 0 : ro.unobserve(prevNode);\n      }\n      _this.measureElementCache[item.key] = node;\n      ro == null ? void 0 : ro.observe(node);\n    }\n    var measuredItemSize = _this.options.measureElement(node, _this);\n    var itemSize = (_this$itemMeasurement = _this.itemMeasurementsCache[item.key]) != null ? _this$itemMeasurement : item.size;\n    var delta = measuredItemSize - itemSize;\n    if (delta !== 0) {\n      var _extends2;\n      if (item.start < _this.scrollOffset && _this.isScrolling) {\n        if (process.env.NODE_ENV !== 'production' && _this.options.debug) {\n          console.info('correction', delta);\n        }\n        _this._scrollToOffset(_this.scrollOffset, {\n          adjustments: _this.scrollAdjustments += delta,\n          behavior: undefined,\n          sync: false\n        });\n      }\n      _this.pendingMeasuredCacheIndexes.push(index);\n      _this.itemMeasurementsCache = _extends({}, _this.itemMeasurementsCache, (_extends2 = {}, _extends2[item.key] = measuredItemSize, _extends2));\n      _this.notify();\n    }\n  };\n  this.measureElement = function (node) {\n    if (!node) {\n      return;\n    }\n    _this._measureElement(node, true);\n  };\n  this.getVirtualItems = memo(function () {\n    return [_this.getIndexes(), _this.getMeasurements()];\n  }, function (indexes, measurements) {\n    var virtualItems = [];\n    for (var k = 0, len = indexes.length; k < len; k++) {\n      var _i3 = indexes[k];\n      var measurement = measurements[_i3];\n      virtualItems.push(measurement);\n    }\n    return virtualItems;\n  }, {\n    key: process.env.NODE_ENV !== 'production' && 'getIndexes',\n    debug: function debug() {\n      return _this.options.debug;\n    }\n  });\n  this.getOffsetForAlignment = function (toOffset, align) {\n    var offset = _this.scrollOffset;\n    var size = _this.getSize();\n    if (align === 'auto') {\n      if (toOffset <= offset) {\n        align = 'start';\n      } else if (toOffset >= offset + size) {\n        align = 'end';\n      } else {\n        align = 'start';\n      }\n    }\n    if (align === 'start') {\n      return toOffset;\n    } else if (align === 'end') {\n      return toOffset - size;\n    } else if (align === 'center') {\n      return toOffset - size / 2;\n    }\n    return toOffset;\n  };\n  this.scrollToOffset = function (toOffset, _temp) {\n    var _ref4 = _temp === void 0 ? {} : _temp,\n      _ref4$align = _ref4.align,\n      align = _ref4$align === void 0 ? 'start' : _ref4$align,\n      behavior = _ref4.behavior;\n    var options = {\n      adjustments: undefined,\n      behavior: behavior,\n      sync: false\n    };\n    _this._scrollToOffset(_this.getOffsetForAlignment(toOffset, align), options);\n  };\n  this.scrollToIndex = function (index, _temp2) {\n    var _ref5 = _temp2 === void 0 ? {} : _temp2,\n      _ref5$align = _ref5.align,\n      align = _ref5$align === void 0 ? 'auto' : _ref5$align,\n      behavior = _ref5.behavior;\n    _this.pendingScrollToIndexCallback = null;\n    var offset = _this.scrollOffset;\n    var size = _this.getSize();\n    var count = _this.options.count;\n    var measurements = _this.getMeasurements();\n    var measurement = measurements[Math.max(0, Math.min(index, count - 1))];\n    if (!measurement) {\n      throw new Error(\"VirtualItem not found for index = \" + index);\n    }\n    if (align === 'auto') {\n      if (measurement.end >= offset + size - _this.options.scrollPaddingEnd) {\n        align = 'end';\n      } else if (measurement.start <= offset + _this.options.scrollPaddingStart) {\n        align = 'start';\n      } else {\n        return;\n      }\n    }\n    var getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(measurement) {\n      var toOffset = align === 'end' ? measurement.end + _this.options.scrollPaddingEnd : measurement.start - _this.options.scrollPaddingStart;\n      return _this.getOffsetForAlignment(toOffset, align);\n    };\n    var toOffset = getOffsetForIndexAndAlignment(measurement);\n    if (toOffset === offset) {\n      return;\n    }\n    var options = {\n      adjustments: undefined,\n      behavior: behavior,\n      sync: false\n    };\n    _this._scrollToOffset(toOffset, options);\n    var isDynamic = Object.keys(_this.measureElementCache).length > 0;\n    if (isDynamic) {\n      _this.pendingScrollToIndexCallback = function () {\n        _this.scrollToIndex(index, {\n          align: align,\n          behavior: behavior\n        });\n      };\n    }\n  };\n  this.scrollBy = function (adjustments, options) {\n    _this._scrollToOffset(_this.scrollOffset, {\n      adjustments: adjustments,\n      behavior: options == null ? void 0 : options.behavior,\n      sync: false\n    });\n  };\n  this.getTotalSize = function () {\n    var _this$getMeasurements;\n    return (((_this$getMeasurements = _this.getMeasurements()[_this.options.count - 1]) == null ? void 0 : _this$getMeasurements.end) || _this.options.paddingStart) + _this.options.paddingEnd;\n  };\n  this._scrollToOffset = function (offset, _ref6) {\n    var adjustments = _ref6.adjustments,\n      behavior = _ref6.behavior,\n      sync = _ref6.sync;\n    _this.options.scrollToFn(offset, {\n      behavior: behavior,\n      sync: sync,\n      adjustments: adjustments\n    }, _this);\n  };\n  this.measure = function () {\n    _this.itemMeasurementsCache = {};\n    _this.notify();\n  };\n  this.setOptions(_opts);\n  this.scrollRect = this.options.initialRect;\n  this.scrollOffset = this.options.initialOffset;\n  this.calculateRange();\n};\nvar findNearestBinarySearch = function findNearestBinarySearch(low, high, getCurrentValue, value) {\n  while (low <= high) {\n    var middle = (low + high) / 2 | 0;\n    var currentValue = getCurrentValue(middle);\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\nfunction calculateRange(_ref7) {\n  var measurements = _ref7.measurements,\n    outerSize = _ref7.outerSize,\n    scrollOffset = _ref7.scrollOffset;\n  var count = measurements.length - 1;\n  var getOffset = function getOffset(index) {\n    return measurements[index].start;\n  };\n  var startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset);\n  var endIndex = startIndex;\n  while (endIndex < count && measurements[endIndex].end < scrollOffset + outerSize) {\n    endIndex++;\n  }\n  return {\n    startIndex: startIndex,\n    endIndex: endIndex\n  };\n}\nexport { Virtualizer, defaultKeyExtractor, defaultRangeExtractor, elementScroll, measureElement, observeElementOffset, observeElementRect, observeWindowOffset, observeWindowRect, windowScroll };","map":{"version":3,"mappings":"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","names":["defaultKeyExtractor","index","defaultRangeExtractor","range","start","Math","max","startIndex","overscan","end","min","endIndex","count","arr","i","push","memoRectCallback","instance","cb","prev","height","width","rect","options","horizontal","observeElementRect","observer","ResizeObserver","entries","contentRect","scrollElement","getBoundingClientRect","observe","unobserve","observeWindowRect","memoizedCallback","onResize","innerWidth","innerHeight","addEventListener","capture","passive","removeEventListener","scrollProps","element","window","createOffsetObserver","mode","propX","propY","prevX","prevY","scroll","offset","scrollMargin","onScroll","e","target","currentTarget","scrollX","scrollY","observeElementOffset","observeWindowOffset","measureElement","round","windowScroll","adjustments","behavior","sync","toOffset","scrollTo","_instance$scrollEleme2","elementScroll","_instance$scrollEleme4","Virtualizer","opts","unsubs","isScrolling","isScrollingTimeoutId","measurementsCache","itemMeasurementsCache","pendingMeasuredCacheIndexes","scrollAdjustments","measureElementCache","pendingScrollToIndexCallback","getResizeObserver","_ro","forEach","entry","_this","_measureElement","setOptions","Object","_ref3","key","value","debug","initialOffset","paddingStart","paddingEnd","scrollPaddingStart","scrollPaddingEnd","getItemKey","rangeExtractor","onChange","initialRect","scrollingDelay","indexAttribute","notify","cleanup","filter","Boolean","d","_didMount","ro","values","node","disconnect","_willUpdate","getScrollElement","_scrollToOffset","scrollOffset","undefined","scrollRect","calculateRange","clearTimeout","onIsScrollingChange","setTimeout","getSize","getMeasurements","memo","length","measurements","slice","measuredSize","size","estimateSize","process","env","NODE_ENV","outerSize","getIndexes","indexFromElement","attributeName","indexStr","getAttribute","console","warn","parseInt","_sync","item","prevNode","isConnected","measuredItemSize","itemSize","delta","info","_extends","_extends2","getVirtualItems","indexes","virtualItems","k","len","measurement","getOffsetForAlignment","align","scrollToOffset","_temp","_ref4$align","scrollToIndex","_temp2","_ref5$align","Error","getOffsetForIndexAndAlignment","isDynamic","keys","scrollBy","getTotalSize","_ref6","scrollToFn","measure","findNearestBinarySearch","low","high","getCurrentValue","middle","currentValue","_ref7","getOffset"],"sources":["/Users/arthur/DEV/buildLookup-dockerDev/front/node_modules/@tanstack/virtual-core/src/index.ts"],"sourcesContent":["import { memo } from './utils'\n\nexport * from './utils'\n\n//\n\ntype ScrollAlignment = 'start' | 'center' | 'end' | 'auto'\n\ntype ScrollBehavior = 'auto' | 'smooth'\n\nexport interface ScrollToOptions {\n  align?: ScrollAlignment\n  behavior?: ScrollBehavior\n}\n\ntype ScrollToOffsetOptions = ScrollToOptions\n\ntype ScrollToIndexOptions = ScrollToOptions\n\nexport interface Range {\n  startIndex: number\n  endIndex: number\n  overscan: number\n  count: number\n}\n\ntype Key = number | string\n\nexport interface VirtualItem {\n  key: Key\n  index: number\n  start: number\n  end: number\n  size: number\n}\n\ninterface Rect {\n  width: number\n  height: number\n}\n\n//\n\nexport const defaultKeyExtractor = (index: number) => index\n\nexport const defaultRangeExtractor = (range: Range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0)\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1)\n\n  const arr = []\n\n  for (let i = start; i <= end; i++) {\n    arr.push(i)\n  }\n\n  return arr\n}\n\nconst memoRectCallback = (\n  instance: Virtualizer<any, any>,\n  cb: (rect: Rect) => void,\n) => {\n  let prev: Rect = { height: -1, width: -1 }\n\n  return (rect: Rect) => {\n    if (\n      instance.options.horizontal\n        ? rect.width !== prev.width\n        : rect.height !== prev.height\n    ) {\n      cb(rect)\n    }\n\n    prev = rect\n  }\n}\n\nexport const observeElementRect = (\n  instance: Virtualizer<any, any>,\n  cb: (rect: Rect) => void,\n) => {\n  const observer = new ResizeObserver((entries) => {\n    cb({\n      width: entries[0]?.contentRect.width as number,\n      height: entries[0]?.contentRect.height as number,\n    })\n  })\n\n  if (!instance.scrollElement) {\n    return\n  }\n\n  cb(instance.scrollElement.getBoundingClientRect())\n\n  observer.observe(instance.scrollElement)\n\n  return () => {\n    observer.unobserve(instance.scrollElement)\n  }\n}\n\nexport const observeWindowRect = (\n  instance: Virtualizer<any, any>,\n  cb: (rect: Rect) => void,\n) => {\n  const memoizedCallback = memoRectCallback(instance, cb)\n  const onResize = () =>\n    memoizedCallback({\n      width: instance.scrollElement.innerWidth,\n      height: instance.scrollElement.innerHeight,\n    })\n\n  if (!instance.scrollElement) {\n    return\n  }\n\n  onResize()\n\n  instance.scrollElement.addEventListener('resize', onResize, {\n    capture: false,\n    passive: true,\n  })\n\n  return () => {\n    instance.scrollElement.removeEventListener('resize', onResize)\n  }\n}\n\ntype ObserverMode = 'element' | 'window'\n\nconst scrollProps = {\n  element: ['scrollLeft', 'scrollTop'],\n  window: ['scrollX', 'scrollY'],\n} as const\n\nconst createOffsetObserver = (mode: ObserverMode) => {\n  return (instance: Virtualizer<any, any>, cb: (offset: number) => void) => {\n    if (!instance.scrollElement) {\n      return\n    }\n\n    const propX = scrollProps[mode][0]\n    const propY = scrollProps[mode][1]\n\n    let prevX: number = instance.scrollElement[propX]\n    let prevY: number = instance.scrollElement[propY]\n\n    const scroll = () => {\n      const offset =\n        instance.scrollElement[instance.options.horizontal ? propX : propY]\n\n      cb(Math.max(0, offset - instance.options.scrollMargin))\n    }\n\n    scroll()\n\n    const onScroll = (e: Event) => {\n      const target = e.currentTarget as HTMLElement & Window\n      const scrollX = target[propX]\n      const scrollY = target[propY]\n\n      if (instance.options.horizontal ? prevX - scrollX : prevY - scrollY) {\n        scroll()\n      }\n\n      prevX = scrollX\n      prevY = scrollY\n    }\n\n    instance.scrollElement.addEventListener('scroll', onScroll, {\n      capture: false,\n      passive: true,\n    })\n\n    return () => {\n      instance.scrollElement.removeEventListener('scroll', onScroll)\n    }\n  }\n}\n\nexport const observeElementOffset = createOffsetObserver('element')\nexport const observeWindowOffset = createOffsetObserver('window')\n\nexport const measureElement = <TItemElement extends Element>(\n  element: TItemElement,\n  instance: Virtualizer<any, TItemElement>,\n) => {\n  return Math.round(\n    element.getBoundingClientRect()[\n      instance.options.horizontal ? 'width' : 'height'\n    ],\n  )\n}\n\nexport const windowScroll = <T extends Window>(\n  offset: number,\n  {\n    adjustments,\n    behavior,\n    sync,\n  }: { adjustments?: number; behavior?: ScrollBehavior; sync: boolean },\n  instance: Virtualizer<T, any>,\n) => {\n  const toOffset =\n    (sync ? offset : offset + instance.options.scrollMargin) +\n    (adjustments ?? 0)\n\n  instance.scrollElement?.scrollTo?.({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior,\n  })\n}\n\nexport const elementScroll = <T extends Element>(\n  offset: number,\n  {\n    adjustments,\n    behavior,\n    sync,\n  }: { adjustments?: number; behavior?: ScrollBehavior; sync: boolean },\n  instance: Virtualizer<T, any>,\n) => {\n  const toOffset =\n    (sync ? offset : offset + instance.options.scrollMargin) +\n    (adjustments ?? 0)\n\n  instance.scrollElement?.scrollTo?.({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior,\n  })\n}\n\nexport interface VirtualizerOptions<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> {\n  // Required from the user\n  count: number\n  getScrollElement: () => TScrollElement | null\n  estimateSize: (index: number) => number\n\n  // Required from the framework adapter (but can be overridden)\n  scrollToFn: (\n    offset: number,\n    options: { adjustments?: number; behavior?: ScrollBehavior; sync: boolean },\n    instance: Virtualizer<TScrollElement, TItemElement>,\n  ) => void\n  observeElementRect: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    cb: (rect: Rect) => void,\n  ) => void | (() => void)\n  observeElementOffset: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    cb: (offset: number) => void,\n  ) => void | (() => void)\n\n  // Optional\n  debug?: any\n  initialRect?: Rect\n  onChange?: (instance: Virtualizer<TScrollElement, TItemElement>) => void\n  measureElement?: (\n    el: TItemElement,\n    instance: Virtualizer<TScrollElement, TItemElement>,\n  ) => number\n  overscan?: number\n  horizontal?: boolean\n  paddingStart?: number\n  paddingEnd?: number\n  scrollPaddingStart?: number\n  scrollPaddingEnd?: number\n  initialOffset?: number\n  getItemKey?: (index: number) => Key\n  rangeExtractor?: (range: Range) => number[]\n  scrollMargin?: number\n  scrollingDelay?: number\n  indexAttribute?: string\n}\n\nexport class Virtualizer<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> {\n  private unsubs: (void | (() => void))[] = []\n  options!: Required<VirtualizerOptions<TScrollElement, TItemElement>>\n  scrollElement: TScrollElement | null = null\n  isScrolling: boolean = false\n  private isScrollingTimeoutId: ReturnType<typeof setTimeout> | null = null\n  measurementsCache: VirtualItem[] = []\n  private itemMeasurementsCache: Record<Key, number> = {}\n  private pendingMeasuredCacheIndexes: number[] = []\n  private scrollRect: Rect\n  scrollOffset: number\n  private scrollAdjustments: number = 0\n  private measureElementCache: Record<Key, TItemElement> = {}\n  private pendingScrollToIndexCallback: (() => void) | null = null\n  private getResizeObserver = (() => {\n    let _ro: ResizeObserver | null = null\n\n    return () => {\n      if (_ro) {\n        return _ro\n      } else if (typeof ResizeObserver !== 'undefined') {\n        return (_ro = new ResizeObserver((entries) => {\n          entries.forEach((entry) => {\n            this._measureElement(entry.target as TItemElement, false)\n          })\n        }))\n      } else {\n        return null\n      }\n    }\n  })()\n  range: { startIndex: number; endIndex: number } = {\n    startIndex: 0,\n    endIndex: 0,\n  }\n\n  constructor(opts: VirtualizerOptions<TScrollElement, TItemElement>) {\n    this.setOptions(opts)\n    this.scrollRect = this.options.initialRect\n    this.scrollOffset = this.options.initialOffset\n\n    this.calculateRange()\n  }\n\n  setOptions = (opts: VirtualizerOptions<TScrollElement, TItemElement>) => {\n    Object.entries(opts).forEach(([key, value]) => {\n      if (typeof value === 'undefined') delete (opts as any)[key]\n    })\n\n    this.options = {\n      debug: false,\n      initialOffset: 0,\n      overscan: 1,\n      paddingStart: 0,\n      paddingEnd: 0,\n      scrollPaddingStart: 0,\n      scrollPaddingEnd: 0,\n      horizontal: false,\n      getItemKey: defaultKeyExtractor,\n      rangeExtractor: defaultRangeExtractor,\n      onChange: () => {},\n      measureElement,\n      initialRect: { width: 0, height: 0 },\n      scrollMargin: 0,\n      scrollingDelay: 150,\n      indexAttribute: 'data-index',\n      ...opts,\n    }\n  }\n\n  private notify = () => {\n    this.options.onChange?.(this)\n  }\n\n  private cleanup = () => {\n    this.unsubs.filter(Boolean).forEach((d) => d!())\n    this.unsubs = []\n    this.scrollElement = null\n  }\n\n  _didMount = () => {\n    const ro = this.getResizeObserver()\n    Object.values(this.measureElementCache).forEach((node) => ro?.observe(node))\n\n    return () => {\n      ro?.disconnect()\n\n      this.cleanup()\n    }\n  }\n\n  _willUpdate = () => {\n    this.pendingScrollToIndexCallback?.()\n\n    const scrollElement = this.options.getScrollElement()\n\n    if (this.scrollElement !== scrollElement) {\n      this.cleanup()\n\n      this.scrollElement = scrollElement\n\n      this._scrollToOffset(this.scrollOffset, {\n        adjustments: undefined,\n        behavior: undefined,\n        sync: true,\n      })\n\n      this.unsubs.push(\n        this.options.observeElementRect(this, (rect) => {\n          this.scrollRect = rect\n          this.calculateRange()\n        }),\n      )\n\n      this.unsubs.push(\n        this.options.observeElementOffset(this, (offset) => {\n          if (this.isScrollingTimeoutId !== null) {\n            clearTimeout(this.isScrollingTimeoutId)\n            this.isScrollingTimeoutId = null\n          }\n\n          const onIsScrollingChange = (isScrolling: boolean) => {\n            if (this.isScrolling !== isScrolling) {\n              this.isScrolling = isScrolling\n              this.notify()\n            }\n          }\n\n          this.scrollAdjustments = 0\n\n          if (this.scrollOffset !== offset) {\n            this.scrollOffset = offset\n            onIsScrollingChange(true)\n          }\n\n          this.calculateRange()\n\n          this.isScrollingTimeoutId = setTimeout(() => {\n            this.isScrollingTimeoutId = null\n            onIsScrollingChange(false)\n          }, this.options.scrollingDelay)\n        }),\n      )\n    } else if (!this.isScrolling) {\n      this.calculateRange()\n    }\n  }\n\n  private getSize = () => {\n    return this.scrollRect[this.options.horizontal ? 'width' : 'height']\n  }\n\n  private getMeasurements = memo(\n    () => [\n      this.options.count,\n      this.options.paddingStart,\n      this.options.getItemKey,\n      this.itemMeasurementsCache,\n    ],\n    (count, paddingStart, getItemKey, measurementsCache) => {\n      const min =\n        this.pendingMeasuredCacheIndexes.length > 0\n          ? Math.min(...this.pendingMeasuredCacheIndexes)\n          : 0\n      this.pendingMeasuredCacheIndexes = []\n\n      const measurements = this.measurementsCache.slice(0, min)\n\n      for (let i = min; i < count; i++) {\n        const key = getItemKey(i)\n        const measuredSize = measurementsCache[key]\n        const start = measurements[i - 1]\n          ? measurements[i - 1]!.end\n          : paddingStart\n        const size =\n          typeof measuredSize === 'number'\n            ? measuredSize\n            : this.options.estimateSize(i)\n        const end = start + size\n        measurements[i] = { index: i, start, size, end, key }\n      }\n\n      this.measurementsCache = measurements\n      return measurements\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getMeasurements',\n      debug: () => this.options.debug,\n    },\n  )\n\n  calculateRange = memo(\n    () => [this.getMeasurements(), this.getSize(), this.scrollOffset],\n    (measurements, outerSize, scrollOffset) => {\n      const range = calculateRange({\n        measurements,\n        outerSize,\n        scrollOffset,\n      })\n      if (\n        range.startIndex !== this.range.startIndex ||\n        range.endIndex !== this.range.endIndex\n      ) {\n        this.range = range\n        this.notify()\n      }\n      return this.range\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'calculateRange',\n      debug: () => this.options.debug,\n    },\n  )\n\n  private getIndexes = memo(\n    () => [\n      this.options.rangeExtractor,\n      this.range,\n      this.options.overscan,\n      this.options.count,\n    ],\n    (rangeExtractor, range, overscan, count) => {\n      return rangeExtractor({\n        ...range,\n        overscan,\n        count: count,\n      })\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getIndexes',\n      debug: () => this.options.debug,\n    },\n  )\n\n  indexFromElement = (node: TItemElement) => {\n    const attributeName = this.options.indexAttribute\n    const indexStr = node.getAttribute(attributeName)\n\n    if (!indexStr) {\n      console.warn(\n        `Missing attribute name '${attributeName}={index}' on measured element.`,\n      )\n      return -1\n    }\n\n    return parseInt(indexStr, 10)\n  }\n\n  private _measureElement = (node: TItemElement, _sync: boolean) => {\n    const index = this.indexFromElement(node)\n\n    const item = this.measurementsCache[index]\n    if (!item) {\n      return\n    }\n\n    const prevNode = this.measureElementCache[item.key]\n\n    const ro = this.getResizeObserver()\n\n    if (!node.isConnected) {\n      if (prevNode) {\n        ro?.unobserve(prevNode)\n        delete this.measureElementCache[item.key]\n      }\n      return\n    }\n\n    if (!prevNode || prevNode !== node) {\n      if (prevNode) {\n        ro?.unobserve(prevNode)\n      }\n      this.measureElementCache[item.key] = node\n      ro?.observe(node)\n    }\n\n    const measuredItemSize = this.options.measureElement(node, this)\n\n    const itemSize = this.itemMeasurementsCache[item.key] ?? item.size\n\n    const delta = measuredItemSize - itemSize\n\n    if (delta !== 0) {\n      if (item.start < this.scrollOffset && this.isScrolling) {\n        if (process.env.NODE_ENV !== 'production' && this.options.debug) {\n          console.info('correction', delta)\n        }\n\n        this._scrollToOffset(this.scrollOffset, {\n          adjustments: (this.scrollAdjustments += delta),\n          behavior: undefined,\n          sync: false,\n        })\n      }\n\n      this.pendingMeasuredCacheIndexes.push(index)\n      this.itemMeasurementsCache = {\n        ...this.itemMeasurementsCache,\n        [item.key]: measuredItemSize,\n      }\n      this.notify()\n    }\n  }\n\n  measureElement = (node: TItemElement | null) => {\n    if (!node) {\n      return\n    }\n\n    this._measureElement(node, true)\n  }\n\n  getVirtualItems = memo(\n    () => [this.getIndexes(), this.getMeasurements()],\n    (indexes, measurements) => {\n      const virtualItems: VirtualItem[] = []\n\n      for (let k = 0, len = indexes.length; k < len; k++) {\n        const i = indexes[k]!\n        const measurement = measurements[i]!\n\n        virtualItems.push(measurement)\n      }\n\n      return virtualItems\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getIndexes',\n      debug: () => this.options.debug,\n    },\n  )\n\n  getOffsetForAlignment = (toOffset: number, align: ScrollAlignment) => {\n    const offset = this.scrollOffset\n    const size = this.getSize()\n\n    if (align === 'auto') {\n      if (toOffset <= offset) {\n        align = 'start'\n      } else if (toOffset >= offset + size) {\n        align = 'end'\n      } else {\n        align = 'start'\n      }\n    }\n\n    if (align === 'start') {\n      return toOffset\n    } else if (align === 'end') {\n      return toOffset - size\n    } else if (align === 'center') {\n      return toOffset - size / 2\n    }\n    return toOffset\n  }\n\n  scrollToOffset = (\n    toOffset: number,\n    { align = 'start', behavior }: ScrollToOffsetOptions = {},\n  ) => {\n    const options = {\n      adjustments: undefined,\n      behavior,\n      sync: false,\n    }\n    this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), options)\n  }\n\n  scrollToIndex = (\n    index: number,\n    { align = 'auto', behavior }: ScrollToIndexOptions = {},\n  ) => {\n    this.pendingScrollToIndexCallback = null\n\n    const offset = this.scrollOffset\n    const size = this.getSize()\n    const { count } = this.options\n\n    const measurements = this.getMeasurements()\n    const measurement = measurements[Math.max(0, Math.min(index, count - 1))]\n\n    if (!measurement) {\n      throw new Error(`VirtualItem not found for index = ${index}`)\n    }\n\n    if (align === 'auto') {\n      if (measurement.end >= offset + size - this.options.scrollPaddingEnd) {\n        align = 'end'\n      } else if (\n        measurement.start <=\n        offset + this.options.scrollPaddingStart\n      ) {\n        align = 'start'\n      } else {\n        return\n      }\n    }\n\n    const getOffsetForIndexAndAlignment = (measurement: VirtualItem) => {\n      const toOffset =\n        align === 'end'\n          ? measurement.end + this.options.scrollPaddingEnd\n          : measurement.start - this.options.scrollPaddingStart\n\n      return this.getOffsetForAlignment(toOffset, align)\n    }\n\n    const toOffset = getOffsetForIndexAndAlignment(measurement)\n\n    if (toOffset === offset) {\n      return\n    }\n\n    const options = {\n      adjustments: undefined,\n      behavior,\n      sync: false,\n    }\n    this._scrollToOffset(toOffset, options)\n\n    const isDynamic = Object.keys(this.measureElementCache).length > 0\n\n    if (isDynamic) {\n      this.pendingScrollToIndexCallback = () => {\n        this.scrollToIndex(index, { align, behavior })\n      }\n    }\n  }\n\n  scrollBy = (adjustments: number, options?: { behavior: ScrollBehavior }) => {\n    this._scrollToOffset(this.scrollOffset, {\n      adjustments,\n      behavior: options?.behavior,\n      sync: false,\n    })\n  }\n\n  getTotalSize = () =>\n    (this.getMeasurements()[this.options.count - 1]?.end ||\n      this.options.paddingStart) + this.options.paddingEnd\n\n  private _scrollToOffset = (\n    offset: number,\n    {\n      adjustments,\n      behavior,\n      sync,\n    }: {\n      adjustments: number | undefined\n      behavior: ScrollBehavior | undefined\n      sync: boolean\n    },\n  ) => {\n    this.options.scrollToFn(offset, { behavior, sync, adjustments }, this)\n  }\n\n  measure = () => {\n    this.itemMeasurementsCache = {}\n    this.notify()\n  }\n}\n\nconst findNearestBinarySearch = (\n  low: number,\n  high: number,\n  getCurrentValue: (i: number) => number,\n  value: number,\n) => {\n  while (low <= high) {\n    const middle = ((low + high) / 2) | 0\n    const currentValue = getCurrentValue(middle)\n\n    if (currentValue < value) {\n      low = middle + 1\n    } else if (currentValue > value) {\n      high = middle - 1\n    } else {\n      return middle\n    }\n  }\n\n  if (low > 0) {\n    return low - 1\n  } else {\n    return 0\n  }\n}\n\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset,\n}: {\n  measurements: VirtualItem[]\n  outerSize: number\n  scrollOffset: number\n}) {\n  const count = measurements.length - 1\n  const getOffset = (index: number) => measurements[index]!.start\n\n  const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset)\n  let endIndex = startIndex\n\n  while (\n    endIndex < count &&\n    measurements[endIndex]!.end < scrollOffset + outerSize\n  ) {\n    endIndex++\n  }\n\n  return { startIndex, endIndex }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}